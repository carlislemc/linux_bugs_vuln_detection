static int bond_ipsec_add_sa(struct xfrm_state *xs)
{
	struct net_device *bond_dev = xs->xso.dev;
	struct bond_ipsec *ipsec;
	struct bonding *bond;
	struct slave *slave;
	int err;

	if (!bond_dev)
		return -EINVAL;

	rcu_read_lock();
	bond = netdev_priv(bond_dev);
	slave = rcu_dereference(bond->curr_active_slave);
	if (!slave) {
		rcu_read_unlock();
		return -ENODEV;
	}

	if (!slave->dev->xfrmdev_ops ||
	    !slave->dev->xfrmdev_ops->xdo_dev_state_add ||
	    netif_is_bond_master(slave->dev)) {
		slave_warn(bond_dev, slave->dev, "Slave does not support ipsec offload\n");
		rcu_read_unlock();
		return -EINVAL;
	}

	ipsec = kmalloc(sizeof(*ipsec), GFP_ATOMIC);
	if (!ipsec) {
		rcu_read_unlock();
		return -ENOMEM;
	}
	xs->xso.real_dev = slave->dev;

	err = slave->dev->xfrmdev_ops->xdo_dev_state_add(xs);
	if (!err) {
		ipsec->xs = xs;
		INIT_LIST_HEAD(&ipsec->list);
		spin_lock_bh(&bond->ipsec_lock);
		list_add(&ipsec->list, &bond->ipsec_list);
		spin_unlock_bh(&bond->ipsec_lock);
	} else {
		kfree(ipsec);
	}
	rcu_read_unlock();
	return err;
}
